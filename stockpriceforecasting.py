# -*- coding: utf-8 -*-
"""StockPriceForecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ThK3vJH3Wguox2kRUjBawevw3vBShS2V

Imports
"""

from tensorflow import keras
import numpy as np
from sklearn.preprocessing import StandardScaler
import seaborn as sns
import os
from datetime import datetime
import yfinance as yf
import matplotlib.pyplot as plt
import pandas as pd

ticker = 'MSFT'
start_date = '2000-01-01'
end_date = pd.Timestamp.today().strftime('%Y-%m-%d')

data = yf.download(ticker, start = start_date, end = end_date)

# Reset index to get 'Date' as a column
data = data.reset_index()

data.head()

data.shape

data.tail()

data.info()

data.describe()

#Initial data visualizations
#Plot1 - Open and Close prices of time
plt.figure(figsize = (12,6))
plt.plot(data['Date'],data['Open'], label = 'Open Price', color = "blue")
plt.plot(data['Date'],data['Close'], label = 'Close Price', color = "red")
plt.title('Open and Close Prices of Time')
plt.legend()
plt.show()

#Plot2 - Trading volume (check for outliers)
plt.figure(figsize = (12,6))
plt.plot(data['Date'],data['Volume'],color="orange")
plt.title('Stock Volume Over Time')
plt.show()

#Drop non-numeric columns

numeric_data = data.select_dtypes(include=["int64","float64"])

# Checking for correlation between features

plt.figure(figsize=(8,6))
sns.heatmap(numeric_data.corr(), annot=True, cmap='coolwarm')
plt.title('Feature Correlation Heatmap')
plt.show()

#Convert the data into date time then create a date filter

data['Date'] = pd.to_datetime(data['Date'])

prediction = data.loc[
    (data['Date'] > datetime(2000,1,1)) &
    (data['Date'] < datetime(2023,1,1))
]

plt.figure(figsize = (12,6))
plt.plot(data['Date'],data['Close'],color="blue")
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.title('Price over time')
plt.show()

#Prepare for the LSTM Model (Sequential)

stock_close = data['Close']

dataset = stock_close.values #convert to numpy array

training_data_len = int(np.ceil(len(dataset)*0.80))

#Preprocessing
scaler = StandardScaler()
scaled_data = scaler.fit_transform(dataset)

training_data = scaled_data[:training_data_len] #80% of all out data

X_train, Y_train = [], []


#Create a Sliding window for our stock (60 days)

for i in range(60, len(training_data)):
  X_train.append(training_data[i-60:i,0])
  Y_train.append(training_data[i,0])

X_train, Y_train = np.array(X_train), np.array(Y_train)

X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

#Build the model

model = keras.models.Sequential()

#first layer
model.add(keras.layers.LSTM(64, return_sequences = True, input_shape = (X_train.shape[1],1)))

#second layer
model.add(keras.layers.LSTM(64, return_sequences = False))

#third layer
model.add(keras.layers.Dense(128, activation="relu"))

#fourth layer
model.add(keras.layers.Dense(1))

#final output layer
model.add(keras.layers.Dense(1))


model.summary()
model.compile(optimizer='adam',
              loss='mae',
              metrics=[keras.metrics.RootMeanSquaredError()])

training = model.fit(X_train, Y_train, epochs=20, batch_size=32)

#prep the test data
test_data = scaled_data[training_data_len - 60:]
X_test, Y_test = [], dataset[training_data_len:]

for i in range(60, len(test_data)):
  X_test.append(test_data[i-60:i,0])

X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

#Make a prediction
predictions = model.predict(X_test)
predictions = scaler.inverse_transform(predictions)

#Plotting data

train = data[:training_data_len]
test = data[training_data_len:]

test = test.copy()

test['Predictions'] = predictions

plt.figure(figsize=(12,8))
plt.plot(train['Date'], train['Close'], label='Training Data (Actual)', color='blue')
plt.plot(test['Date'], test['Close'], label='Test (Actual) Data', color='orange')
plt.plot(test['Date'], test['Predictions'], label='Predicted Data', color='red')

plt.title("Our Stock Predictions")
plt.xlabel("Date")
plt.ylabel("Close Price")
plt.legend()
plt.show()

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

mae = mean_absolute_error(Y_test, predictions)
rmse = np.sqrt(mse)
r2 = r2_score(Y_test, predictions)

print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")
print(f"RÂ² Score: {r2:.4f}")